Web VPython 3.2

# set scene
scene.background = color.white
scene.width = 1000
scene.height = 650
scene.range = 1
# Use it to make it seem 2D
# scene.fov = pi / 78 

#constants (don't ask me when k is so low, I will change it later!!!)
K = 9E-7
# I will figure it out so I don't need to divide by 1000 later !!!
vectorAxisFactor = 500

# electric field stuff
electricFieldOpacitySetter = 1E-4
steps = 10

electricFieldArrowsAll = [ [0]*steps for i in range(steps)]
for i in range(steps):
    for j in range(steps):
        electricFieldArrowsAll[i][j] = arrow(axis = vec(0, 0, 0), color = color.orange)

def setElectricFieldArrowsAll():
    for i in range(steps):
        for j in range(steps):
            electricFieldArrowsAll[i][j].visible = True
            # assume height > width
            electricFieldArrowsAll[i][j].pos = vec(
                        (i - steps / 2) * 2 * scene.width / scene.height * scene.range / steps, 
                        (j - steps / 2) * 2 * scene.range / steps, 0)
            electricFieldArrowsAll[i][j].pos += vec(
                        scene.width / scene.height * scene.range / steps, 
                        scene.range / steps, 0)
            
setElectricFieldArrowsAll()

# store all spawned charges
allChargedObjs = []

# Class Charge
class ChargedObj:
    def __init__(self, mass, charge, spawnPos, spawnVel):
        # physics variables
        self.charge = charge
        self.mass = mass
        self.pos = spawnPos
        self.vel = spawnVel
        self.fixed = False
        # Displays
        # spheres for now
        if (charge > 0):
            self.display = sphere(pos=spawnPos, radius=0.05, color = color.red)
        if (charge < 0):
            self.display = sphere(pos=spawnPos, radius=0.05, color = color.blue)
        if (charge == 0):
            self.display = sphere(pos=spawnPos, radius=0.05, color = color.black)
        self.velVec = arrow(axis = vec(0, 0, 0), color = self.display.color)
        self.forceVec = arrow(axis = vec(0, 0, 0), color = self.display.color)
        
        # electric field
        # possibly sliders for more variables
        self.numOfLine = 8
        # initialize all the arrows
        self.electricFieldArrows = [ [0]*steps for i in range(self.numOfLine)]
        for i in range(self.numOfLine):
            for j in range(steps):
                self.electricFieldArrows[i][j] = arrow(axis = vec(0, 0, 0), color = self.display.color)
    
    def applyForce(self):
        # calculate force from every other charge
        if (not self.fixed):
            force = vec(0, 0, 0)
            for chargedObj in allChargedObjs:
                if (chargedObj != self):
                    if (mag(self.pos - chargedObj.pos) > 2 * self.display.radius):
                        force += calculateForce(self, chargedObj)
            # apply force
            self.vel += force / self.mass

    def applyVel(self):
        if (not self.fixed):
            self.pos += self.vel
            self.display.pos = self.pos
    
    def checkCollision(self):
        for chargedObj in allChargedObjs:
            if (mag(self.pos - chargedObj.pos) <= 2 * self.display.radius):
                self.vel = vec(0, 0, 0)
                chargedObj.vel = vec(0, 0, 0)

    def displayElectricField(self):
        if (electricFieldMode == 1):
            # determine size
            size = scene.range / 10
            # for every direction
            for i in range(self.numOfLine):
                # determine starting position
                theta = i * 2 * pi / self.numOfLine
                curPos = self.pos + vec(cos(theta), sin(theta), 0) * self.display.radius
                endForTooClose = False
                #for every step
                for j in range(steps):
                    # stop if too close to a charge
                    if (tooClose(self, curPos, size)):
                        endForTooClose = True
                    if (endForTooClose):
                        self.electricFieldArrows[i][j].visible = False
                    else:
                        # determine the arrow and the next position
                        electricField = calculateElectricField(curPos)
                        arrowLength = norm(electricField) * size
                        self.electricFieldArrows[i][j].visible = True
                        self.electricFieldArrows[i][j].pos = curPos
                        if (self.charge < 0):
                            self.electricFieldArrows[i][j].pos -= arrowLength
                        self.electricFieldArrows[i][j].axis = arrowLength
                        self.electricFieldArrows[i][j].opacity = mag(electricField) / electricFieldOpacitySetter
                        curPos += arrowLength * self.charge / abs(self.charge)
        else: 
            # hide all electric field arrows
            for i in range(self.numOfLine):   
                for j in range(steps):
                    self.electricFieldArrows[i][j].visible = False

# Coulomb's Law for force of q2 on q1
def calculateForce(q1, q2):
    r12 = q1.pos - q2.pos
    return norm(r12) * K * q1.charge * q2.charge / (mag(r12)**2)

####################################################################################################

# Electric Field

def displayElectricFieldAll():
    if (electricFieldMode == 2):
        size = scene.range / 20
        for i in range(steps):
            for j in range(steps):
                electricFieldArrowsAll[i][j].visible = True
                electricFieldArrowsAll[i][j].axis = norm(calculateElectricField(electricFieldArrowsAll[i][j].pos)) * size
    else:
        # hide all electric field
        for i in range(steps):
            for j in range(steps):
                electricFieldArrowsAll[i][j].visible = False
    
def calculateElectricField(pos):
    electricField = vec(0, 0, 0)
    for chargedObj in allChargedObjs:
        r = pos - chargedObj.pos
        # just check for now before I figure out what to do in this case
        if (mag(r) != 0):
            electricField += norm(r) * K * chargedObj.charge / (mag(r)**2)
    return electricField

def tooClose(owner, pos, size):
    for chargedObj in allChargedObjs:
            if (chargedObj != owner):
                if mag(pos - chargedObj.pos) < chargedObj.display.radius + size:
                    return True
    return False

####################################################################################################

# Clicks
chargedObjSelected = undefined

def clicked():
    if (clickMode == "Spawn"):
        makeChargeObj()
    elif (clickMode == "Select"):
        selectCharge()

scene.bind('click', clicked)

def makeChargeObj():
    allChargedObjs.append(ChargedObj(1, spawnCharge, getMousePos(), vec(0, 0, 0)))

def selectCharge():
    global chargedObjSelected
    chargedObjSelected = chargedObjOnMouse()

def chargedObjOnMouse():
    mousePos = getMousePos()
    for chargedObj in allChargedObjs:
        if (mag(mousePos - chargedObj.pos) <= chargedObj.display.radius):
            return chargedObj
        
def getMousePos():
    return scene.mouse.project(normal=vec(0, 0, 1))

# dragging
chargedObjToDrag = undefined

def on_mouse_down():
    global chargedObjToDrag
    chargedObjToDrag = chargedObjOnMouse()

def on_mouse_up():
    global chargedObjToDrag
    # apply force vector if necessary
    if (chargedObjToDrag != undefined):
        if (chargedObjToDrag.forceVec.axis != vec(0, 0, 0)):
            chargedObjToDrag.vel += chargedObjToDrag.forceVec.axis / vectorAxisFactor / chargedObjToDrag.mass 
            chargedObjToDrag.forceVec.axis = vec(0, 0, 0)
    chargedObjToDrag = undefined

def on_mouse_move():
    if (clickMode == "Spawn"):
        # set position
        if chargedObjToDrag != undefined:
            chargedObjToDrag.pos = getMousePos()
            chargedObjToDrag.display.pos = chargedObjToDrag.pos
            chargedObjToDrag.velVec.pos = chargedObjToDrag.pos
    else:
        if chargedObjToDrag != undefined:
            # force vector
            if (playing):
                chargedObjToDrag.forceVec.pos = chargedObjToDrag.pos
                chargedObjToDrag.forceVec.axis = getMousePos() - chargedObjToDrag.pos 
            # velocity vector
            else:
                chargedObjToDrag.velVec.pos = chargedObjToDrag.pos
                chargedObjToDrag.velVec.axis = getMousePos() - chargedObjToDrag.pos
                chargedObjToDrag.vel = chargedObjToDrag.velVec.axis / vectorAxisFactor

# Bind event handlers to the box
scene.bind('mousedown', on_mouse_down)
scene.bind('mouseup', on_mouse_up)

####################################################################################################

# Button and Sliders

# mode button
clickMode = "Spawn"

def changeClickMode():
    global clickMode, clickModeButton
    if clickMode == "Spawn":
        clickMode = "Select"
    else:
        clickMode = "Spawn"
    clickModeButton.text = "Mode: " + clickMode

scene.append_to_caption("   ")
clickModeButton = button(text="Mode: Spawn", bind=changeClickMode)

# spawn slider
spawnCharge = 1

def spawnChargeShift():
    global spawnCharge, spawnChargeText
    spawnCharge = s.value
    spawnChargeText.text = 'Charge:'+'{:1.2f}'.format(s.value)

s = slider(bind = spawnChargeShift, min = -5, max = 5, value = 1)
spawnChargeText = wtext(text = 'Charge:'+'{:1.2f}'.format(s.value))

# delete button
def deleteChargedObj():
    if (chargedObjSelected != undefined):
        chargedObjSelected.display.visible = False
        chargedObjSelected.velVec.visible = False
        chargedObjSelected.forceVec.visible = False
        for i in range(chargedObjSelected.numOfLine):   
                for j in range(steps):
                    chargedObjSelected.electricFieldArrows[i][j].visible = False
        allChargedObjs.remove(chargedObjSelected)

scene.append_to_caption("   ")
deleteButton = button(text="Delete", bind=deleteChargedObj)

# fix button
def fixChargedObj():
    if (chargedObjSelected != undefined):
        chargedObjSelected.fixed = not chargedObjSelected.fixed

scene.append_to_caption("   ")
fixButton = button(text="Fix", bind=fixChargedObj)

# electic field button
electricFieldMode = 0

def changeElectricField():
    global electricFieldMode, electricFieldButton
    electricFieldMode += 1
    if electricFieldMode == 3:
        electricFieldMode = 0
    electricFieldButton.text = "Electric Field: Mode " + str(electricFieldMode)

scene.append_to_caption("   ")
electricFieldButton = button(text="Electric Field: Mode 1", bind=changeElectricField)

# playing button
playing = False

def changePlay():
    global playing, playButton
    playing = not playing
    if playing:
        playButton.text = "Stop"
    else:
        playButton.text = "Play"
    #set velocity vector visibilities
    if (playing):
        for co in allChargedObjs:
            co.velVec.visible = False
    else:
        for co in allChargedObjs:
            co.velVec.visible = True
            co.velVec.pos = co.pos
            co.velVec.axis = co.vel * vectorAxisFactor

scene.append_to_caption("   ")
playButton = button(text="Play", bind=changePlay)

curRange = scene.range

while True:
    rate(1000)
    if (playing):
        for chargedObj in allChargedObjs:
            chargedObj.applyForce()
        for chargedObj in allChargedObjs:
            chargedObj.applyVel()
    for chargedObj in allChargedObjs:
        chargedObj.displayElectricField()

    if (curRange != scene.range):
        curRange = scene.range
        setElectricFieldArrowsAll()

    displayElectricFieldAll()
    # for charge in allChargedObjs:
    #     charge.checkCollision()

    # need to call mouse move any frame since for force vector mouse could have been not moving
    on_mouse_move()
        
